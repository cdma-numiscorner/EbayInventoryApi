<?php
/**
 * OfferApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\EbayInventoryClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Inventory API
 *
 * The Inventory API is used to create and manage inventory, and then to publish and manage this inventory on an eBay marketplace. There are also methods in this API that will convert eligible, active eBay listings into the Inventory API model.
 *
 * The version of the OpenAPI document: 1.16.1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\EbayInventoryClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\EbayInventoryClient\ApiException;
use OpenAPI\EbayInventoryClient\Configuration;
use OpenAPI\EbayInventoryClient\HeaderSelector;
use OpenAPI\EbayInventoryClient\ObjectSerializer;

/**
 * OfferApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\EbayInventoryClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OfferApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'bulkCreateOffer' => [
            'application/json',
        ],
        'bulkPublishOffer' => [
            'application/json',
        ],
        'createOffer' => [
            'application/json',
        ],
        'deleteOffer' => [
            'application/json',
        ],
        'getListingFees' => [
            'application/json',
        ],
        'getOffer' => [
            'application/json',
        ],
        'getOffers' => [
            'application/json',
        ],
        'publishOffer' => [
            'application/json',
        ],
        'publishOfferByInventoryItemGroup' => [
            'application/json',
        ],
        'updateOffer' => [
            'application/json',
        ],
        'withdrawOffer' => [
            'application/json',
        ],
        'withdrawOfferByInventoryItemGroup' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bulkCreateOffer
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkEbayOfferDetailsWithKeys $bulk_ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\BulkOfferResponse
     */
    public function bulkCreateOffer($bulk_ebay_offer_details_with_keys, string $contentType = self::contentTypes['bulkCreateOffer'][0])
    {
        list($response) = $this->bulkCreateOfferWithHttpInfo($bulk_ebay_offer_details_with_keys, $contentType);
        return $response;
    }

    /**
     * Operation bulkCreateOfferWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkEbayOfferDetailsWithKeys $bulk_ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\BulkOfferResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkCreateOfferWithHttpInfo($bulk_ebay_offer_details_with_keys, string $contentType = self::contentTypes['bulkCreateOffer'][0])
    {
        $request = $this->bulkCreateOfferRequest($bulk_ebay_offer_details_with_keys, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\BulkOfferResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\BulkOfferResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\BulkOfferResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\BulkOfferResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\BulkOfferResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkCreateOfferAsync
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkEbayOfferDetailsWithKeys $bulk_ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkCreateOfferAsync($bulk_ebay_offer_details_with_keys, string $contentType = self::contentTypes['bulkCreateOffer'][0])
    {
        return $this->bulkCreateOfferAsyncWithHttpInfo($bulk_ebay_offer_details_with_keys, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkCreateOfferAsyncWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkEbayOfferDetailsWithKeys $bulk_ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkCreateOfferAsyncWithHttpInfo($bulk_ebay_offer_details_with_keys, string $contentType = self::contentTypes['bulkCreateOffer'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\BulkOfferResponse';
        $request = $this->bulkCreateOfferRequest($bulk_ebay_offer_details_with_keys, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkCreateOffer'
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkEbayOfferDetailsWithKeys $bulk_ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkCreateOfferRequest($bulk_ebay_offer_details_with_keys, string $contentType = self::contentTypes['bulkCreateOffer'][0])
    {

        // verify the required parameter 'bulk_ebay_offer_details_with_keys' is set
        if ($bulk_ebay_offer_details_with_keys === null || (is_array($bulk_ebay_offer_details_with_keys) && count($bulk_ebay_offer_details_with_keys) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_ebay_offer_details_with_keys when calling bulkCreateOffer'
            );
        }


        $resourcePath = '/bulk_create_offer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_ebay_offer_details_with_keys)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_ebay_offer_details_with_keys));
            } else {
                $httpBody = $bulk_ebay_offer_details_with_keys;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkPublishOffer
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkOffer $bulk_offer The base request of the &lt;strong&gt;bulkPublishOffer&lt;/strong&gt; method. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkPublishOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\BulkPublishResponse
     */
    public function bulkPublishOffer($bulk_offer, string $contentType = self::contentTypes['bulkPublishOffer'][0])
    {
        list($response) = $this->bulkPublishOfferWithHttpInfo($bulk_offer, $contentType);
        return $response;
    }

    /**
     * Operation bulkPublishOfferWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkOffer $bulk_offer The base request of the &lt;strong&gt;bulkPublishOffer&lt;/strong&gt; method. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkPublishOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\BulkPublishResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkPublishOfferWithHttpInfo($bulk_offer, string $contentType = self::contentTypes['bulkPublishOffer'][0])
    {
        $request = $this->bulkPublishOfferRequest($bulk_offer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\BulkPublishResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\BulkPublishResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\BulkPublishResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\BulkPublishResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\BulkPublishResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkPublishOfferAsync
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkOffer $bulk_offer The base request of the &lt;strong&gt;bulkPublishOffer&lt;/strong&gt; method. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkPublishOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkPublishOfferAsync($bulk_offer, string $contentType = self::contentTypes['bulkPublishOffer'][0])
    {
        return $this->bulkPublishOfferAsyncWithHttpInfo($bulk_offer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkPublishOfferAsyncWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkOffer $bulk_offer The base request of the &lt;strong&gt;bulkPublishOffer&lt;/strong&gt; method. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkPublishOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkPublishOfferAsyncWithHttpInfo($bulk_offer, string $contentType = self::contentTypes['bulkPublishOffer'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\BulkPublishResponse';
        $request = $this->bulkPublishOfferRequest($bulk_offer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkPublishOffer'
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\BulkOffer $bulk_offer The base request of the &lt;strong&gt;bulkPublishOffer&lt;/strong&gt; method. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkPublishOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkPublishOfferRequest($bulk_offer, string $contentType = self::contentTypes['bulkPublishOffer'][0])
    {

        // verify the required parameter 'bulk_offer' is set
        if ($bulk_offer === null || (is_array($bulk_offer) && count($bulk_offer) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_offer when calling bulkPublishOffer'
            );
        }


        $resourcePath = '/bulk_publish_offer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_offer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_offer));
            } else {
                $httpBody = $bulk_offer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOffer
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithKeys $ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\OfferResponse
     */
    public function createOffer($content_language, $ebay_offer_details_with_keys, string $contentType = self::contentTypes['createOffer'][0])
    {
        list($response) = $this->createOfferWithHttpInfo($content_language, $ebay_offer_details_with_keys, $contentType);
        return $response;
    }

    /**
     * Operation createOfferWithHttpInfo
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithKeys $ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\OfferResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOfferWithHttpInfo($content_language, $ebay_offer_details_with_keys, string $contentType = self::contentTypes['createOffer'][0])
    {
        $request = $this->createOfferRequest($content_language, $ebay_offer_details_with_keys, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\EbayInventoryClient\Model\OfferResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\OfferResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\OfferResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\OfferResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\OfferResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOfferAsync
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithKeys $ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOfferAsync($content_language, $ebay_offer_details_with_keys, string $contentType = self::contentTypes['createOffer'][0])
    {
        return $this->createOfferAsyncWithHttpInfo($content_language, $ebay_offer_details_with_keys, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOfferAsyncWithHttpInfo
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithKeys $ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOfferAsyncWithHttpInfo($content_language, $ebay_offer_details_with_keys, string $contentType = self::contentTypes['createOffer'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\OfferResponse';
        $request = $this->createOfferRequest($content_language, $ebay_offer_details_with_keys, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOffer'
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithKeys $ebay_offer_details_with_keys Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOfferRequest($content_language, $ebay_offer_details_with_keys, string $contentType = self::contentTypes['createOffer'][0])
    {

        // verify the required parameter 'content_language' is set
        if ($content_language === null || (is_array($content_language) && count($content_language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_language when calling createOffer'
            );
        }

        // verify the required parameter 'ebay_offer_details_with_keys' is set
        if ($ebay_offer_details_with_keys === null || (is_array($ebay_offer_details_with_keys) && count($ebay_offer_details_with_keys) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ebay_offer_details_with_keys when calling createOffer'
            );
        }


        $resourcePath = '/offer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($content_language !== null) {
            $headerParams['Content-Language'] = ObjectSerializer::toHeaderValue($content_language);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ebay_offer_details_with_keys)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ebay_offer_details_with_keys));
            } else {
                $httpBody = $ebay_offer_details_with_keys;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOffer
     *
     * @param  string $offer_id The unique identifier of the offer to delete. The unique identifier of the offer (&lt;strong&gt;offerId&lt;/strong&gt;) is passed in at the end of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOffer($offer_id, string $contentType = self::contentTypes['deleteOffer'][0])
    {
        $this->deleteOfferWithHttpInfo($offer_id, $contentType);
    }

    /**
     * Operation deleteOfferWithHttpInfo
     *
     * @param  string $offer_id The unique identifier of the offer to delete. The unique identifier of the offer (&lt;strong&gt;offerId&lt;/strong&gt;) is passed in at the end of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOfferWithHttpInfo($offer_id, string $contentType = self::contentTypes['deleteOffer'][0])
    {
        $request = $this->deleteOfferRequest($offer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOfferAsync
     *
     * @param  string $offer_id The unique identifier of the offer to delete. The unique identifier of the offer (&lt;strong&gt;offerId&lt;/strong&gt;) is passed in at the end of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOfferAsync($offer_id, string $contentType = self::contentTypes['deleteOffer'][0])
    {
        return $this->deleteOfferAsyncWithHttpInfo($offer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOfferAsyncWithHttpInfo
     *
     * @param  string $offer_id The unique identifier of the offer to delete. The unique identifier of the offer (&lt;strong&gt;offerId&lt;/strong&gt;) is passed in at the end of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOfferAsyncWithHttpInfo($offer_id, string $contentType = self::contentTypes['deleteOffer'][0])
    {
        $returnType = '';
        $request = $this->deleteOfferRequest($offer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOffer'
     *
     * @param  string $offer_id The unique identifier of the offer to delete. The unique identifier of the offer (&lt;strong&gt;offerId&lt;/strong&gt;) is passed in at the end of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteOfferRequest($offer_id, string $contentType = self::contentTypes['deleteOffer'][0])
    {

        // verify the required parameter 'offer_id' is set
        if ($offer_id === null || (is_array($offer_id) && count($offer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offer_id when calling deleteOffer'
            );
        }


        $resourcePath = '/offer/{offerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($offer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'offerId' . '}',
                ObjectSerializer::toPathValue($offer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getListingFees
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\OfferKeysWithId $offer_keys_with_id List of offers that needs fee information (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListingFees'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\FeesSummaryResponse
     */
    public function getListingFees($offer_keys_with_id = null, string $contentType = self::contentTypes['getListingFees'][0])
    {
        list($response) = $this->getListingFeesWithHttpInfo($offer_keys_with_id, $contentType);
        return $response;
    }

    /**
     * Operation getListingFeesWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\OfferKeysWithId $offer_keys_with_id List of offers that needs fee information (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListingFees'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\FeesSummaryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListingFeesWithHttpInfo($offer_keys_with_id = null, string $contentType = self::contentTypes['getListingFees'][0])
    {
        $request = $this->getListingFeesRequest($offer_keys_with_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\FeesSummaryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\FeesSummaryResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\FeesSummaryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\FeesSummaryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\FeesSummaryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getListingFeesAsync
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\OfferKeysWithId $offer_keys_with_id List of offers that needs fee information (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListingFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListingFeesAsync($offer_keys_with_id = null, string $contentType = self::contentTypes['getListingFees'][0])
    {
        return $this->getListingFeesAsyncWithHttpInfo($offer_keys_with_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListingFeesAsyncWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\OfferKeysWithId $offer_keys_with_id List of offers that needs fee information (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListingFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListingFeesAsyncWithHttpInfo($offer_keys_with_id = null, string $contentType = self::contentTypes['getListingFees'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\FeesSummaryResponse';
        $request = $this->getListingFeesRequest($offer_keys_with_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getListingFees'
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\OfferKeysWithId $offer_keys_with_id List of offers that needs fee information (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListingFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getListingFeesRequest($offer_keys_with_id = null, string $contentType = self::contentTypes['getListingFees'][0])
    {



        $resourcePath = '/offer/get_listing_fees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($offer_keys_with_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($offer_keys_with_id));
            } else {
                $httpBody = $offer_keys_with_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOffer
     *
     * @param  string $offer_id The unique identifier of the offer that is to be retrieved. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithAll
     */
    public function getOffer($offer_id, string $contentType = self::contentTypes['getOffer'][0])
    {
        list($response) = $this->getOfferWithHttpInfo($offer_id, $contentType);
        return $response;
    }

    /**
     * Operation getOfferWithHttpInfo
     *
     * @param  string $offer_id The unique identifier of the offer that is to be retrieved. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithAll, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOfferWithHttpInfo($offer_id, string $contentType = self::contentTypes['getOffer'][0])
    {
        $request = $this->getOfferRequest($offer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithAll' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithAll' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithAll', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithAll';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithAll',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOfferAsync
     *
     * @param  string $offer_id The unique identifier of the offer that is to be retrieved. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOfferAsync($offer_id, string $contentType = self::contentTypes['getOffer'][0])
    {
        return $this->getOfferAsyncWithHttpInfo($offer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOfferAsyncWithHttpInfo
     *
     * @param  string $offer_id The unique identifier of the offer that is to be retrieved. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOfferAsyncWithHttpInfo($offer_id, string $contentType = self::contentTypes['getOffer'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithAll';
        $request = $this->getOfferRequest($offer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOffer'
     *
     * @param  string $offer_id The unique identifier of the offer that is to be retrieved. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOfferRequest($offer_id, string $contentType = self::contentTypes['getOffer'][0])
    {

        // verify the required parameter 'offer_id' is set
        if ($offer_id === null || (is_array($offer_id) && count($offer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offer_id when calling getOffer'
            );
        }


        $resourcePath = '/offer/{offerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($offer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'offerId' . '}',
                ObjectSerializer::toPathValue($offer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOffers
     *
     * @param  string $format This enumeration value sets the listing format for the offer. This query parameter will be passed in if the seller only wants to see offers in this specified listing format. (optional)
     * @param  string $limit The value passed in this query parameter sets the maximum number of records to return per page of data. Although this field is a string, the value passed in this field should be a positive integer value. If this query parameter is not set, up to 100 records will be returned on each page of results. (optional)
     * @param  string $marketplace_id The unique identifier of the eBay marketplace. This query parameter will be passed in if the seller only wants to see the product&#39;s offers on a specific eBay marketplace.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; At this time, the same SKU value can not be offered across multiple eBay marketplaces, so the &lt;strong&gt;marketplace_id&lt;/strong&gt; query parameter currently does not have any practical use for this call.&lt;/span&gt; (optional)
     * @param  string $offset The value passed in this query parameter sets the page number to retrieve. Although this field is a string, the value passed in this field should be a integer value equal to or greater than &lt;code&gt;0&lt;/code&gt;. The first page of records has a value of &lt;code&gt;0&lt;/code&gt;, the second page of records has a value of &lt;code&gt;1&lt;/code&gt;, and so on. If this query parameter is not set, its value defaults to &lt;code&gt;0&lt;/code&gt;, and the first page of records is returned. (optional)
     * @param  string $sku The seller-defined SKU value is passed in as a query parameter. All offers associated with this product are returned in the response.&lt;br/&gt;&lt;br/&gt; &lt;strong&gt;Max length&lt;/strong&gt;: 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\Offers
     */
    public function getOffers($format = null, $limit = null, $marketplace_id = null, $offset = null, $sku = null, string $contentType = self::contentTypes['getOffers'][0])
    {
        list($response) = $this->getOffersWithHttpInfo($format, $limit, $marketplace_id, $offset, $sku, $contentType);
        return $response;
    }

    /**
     * Operation getOffersWithHttpInfo
     *
     * @param  string $format This enumeration value sets the listing format for the offer. This query parameter will be passed in if the seller only wants to see offers in this specified listing format. (optional)
     * @param  string $limit The value passed in this query parameter sets the maximum number of records to return per page of data. Although this field is a string, the value passed in this field should be a positive integer value. If this query parameter is not set, up to 100 records will be returned on each page of results. (optional)
     * @param  string $marketplace_id The unique identifier of the eBay marketplace. This query parameter will be passed in if the seller only wants to see the product&#39;s offers on a specific eBay marketplace.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; At this time, the same SKU value can not be offered across multiple eBay marketplaces, so the &lt;strong&gt;marketplace_id&lt;/strong&gt; query parameter currently does not have any practical use for this call.&lt;/span&gt; (optional)
     * @param  string $offset The value passed in this query parameter sets the page number to retrieve. Although this field is a string, the value passed in this field should be a integer value equal to or greater than &lt;code&gt;0&lt;/code&gt;. The first page of records has a value of &lt;code&gt;0&lt;/code&gt;, the second page of records has a value of &lt;code&gt;1&lt;/code&gt;, and so on. If this query parameter is not set, its value defaults to &lt;code&gt;0&lt;/code&gt;, and the first page of records is returned. (optional)
     * @param  string $sku The seller-defined SKU value is passed in as a query parameter. All offers associated with this product are returned in the response.&lt;br/&gt;&lt;br/&gt; &lt;strong&gt;Max length&lt;/strong&gt;: 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\Offers, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOffersWithHttpInfo($format = null, $limit = null, $marketplace_id = null, $offset = null, $sku = null, string $contentType = self::contentTypes['getOffers'][0])
    {
        $request = $this->getOffersRequest($format, $limit, $marketplace_id, $offset, $sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\Offers' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\Offers' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\Offers', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\Offers';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\Offers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOffersAsync
     *
     * @param  string $format This enumeration value sets the listing format for the offer. This query parameter will be passed in if the seller only wants to see offers in this specified listing format. (optional)
     * @param  string $limit The value passed in this query parameter sets the maximum number of records to return per page of data. Although this field is a string, the value passed in this field should be a positive integer value. If this query parameter is not set, up to 100 records will be returned on each page of results. (optional)
     * @param  string $marketplace_id The unique identifier of the eBay marketplace. This query parameter will be passed in if the seller only wants to see the product&#39;s offers on a specific eBay marketplace.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; At this time, the same SKU value can not be offered across multiple eBay marketplaces, so the &lt;strong&gt;marketplace_id&lt;/strong&gt; query parameter currently does not have any practical use for this call.&lt;/span&gt; (optional)
     * @param  string $offset The value passed in this query parameter sets the page number to retrieve. Although this field is a string, the value passed in this field should be a integer value equal to or greater than &lt;code&gt;0&lt;/code&gt;. The first page of records has a value of &lt;code&gt;0&lt;/code&gt;, the second page of records has a value of &lt;code&gt;1&lt;/code&gt;, and so on. If this query parameter is not set, its value defaults to &lt;code&gt;0&lt;/code&gt;, and the first page of records is returned. (optional)
     * @param  string $sku The seller-defined SKU value is passed in as a query parameter. All offers associated with this product are returned in the response.&lt;br/&gt;&lt;br/&gt; &lt;strong&gt;Max length&lt;/strong&gt;: 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOffersAsync($format = null, $limit = null, $marketplace_id = null, $offset = null, $sku = null, string $contentType = self::contentTypes['getOffers'][0])
    {
        return $this->getOffersAsyncWithHttpInfo($format, $limit, $marketplace_id, $offset, $sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOffersAsyncWithHttpInfo
     *
     * @param  string $format This enumeration value sets the listing format for the offer. This query parameter will be passed in if the seller only wants to see offers in this specified listing format. (optional)
     * @param  string $limit The value passed in this query parameter sets the maximum number of records to return per page of data. Although this field is a string, the value passed in this field should be a positive integer value. If this query parameter is not set, up to 100 records will be returned on each page of results. (optional)
     * @param  string $marketplace_id The unique identifier of the eBay marketplace. This query parameter will be passed in if the seller only wants to see the product&#39;s offers on a specific eBay marketplace.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; At this time, the same SKU value can not be offered across multiple eBay marketplaces, so the &lt;strong&gt;marketplace_id&lt;/strong&gt; query parameter currently does not have any practical use for this call.&lt;/span&gt; (optional)
     * @param  string $offset The value passed in this query parameter sets the page number to retrieve. Although this field is a string, the value passed in this field should be a integer value equal to or greater than &lt;code&gt;0&lt;/code&gt;. The first page of records has a value of &lt;code&gt;0&lt;/code&gt;, the second page of records has a value of &lt;code&gt;1&lt;/code&gt;, and so on. If this query parameter is not set, its value defaults to &lt;code&gt;0&lt;/code&gt;, and the first page of records is returned. (optional)
     * @param  string $sku The seller-defined SKU value is passed in as a query parameter. All offers associated with this product are returned in the response.&lt;br/&gt;&lt;br/&gt; &lt;strong&gt;Max length&lt;/strong&gt;: 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOffersAsyncWithHttpInfo($format = null, $limit = null, $marketplace_id = null, $offset = null, $sku = null, string $contentType = self::contentTypes['getOffers'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\Offers';
        $request = $this->getOffersRequest($format, $limit, $marketplace_id, $offset, $sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOffers'
     *
     * @param  string $format This enumeration value sets the listing format for the offer. This query parameter will be passed in if the seller only wants to see offers in this specified listing format. (optional)
     * @param  string $limit The value passed in this query parameter sets the maximum number of records to return per page of data. Although this field is a string, the value passed in this field should be a positive integer value. If this query parameter is not set, up to 100 records will be returned on each page of results. (optional)
     * @param  string $marketplace_id The unique identifier of the eBay marketplace. This query parameter will be passed in if the seller only wants to see the product&#39;s offers on a specific eBay marketplace.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; At this time, the same SKU value can not be offered across multiple eBay marketplaces, so the &lt;strong&gt;marketplace_id&lt;/strong&gt; query parameter currently does not have any practical use for this call.&lt;/span&gt; (optional)
     * @param  string $offset The value passed in this query parameter sets the page number to retrieve. Although this field is a string, the value passed in this field should be a integer value equal to or greater than &lt;code&gt;0&lt;/code&gt;. The first page of records has a value of &lt;code&gt;0&lt;/code&gt;, the second page of records has a value of &lt;code&gt;1&lt;/code&gt;, and so on. If this query parameter is not set, its value defaults to &lt;code&gt;0&lt;/code&gt;, and the first page of records is returned. (optional)
     * @param  string $sku The seller-defined SKU value is passed in as a query parameter. All offers associated with this product are returned in the response.&lt;br/&gt;&lt;br/&gt; &lt;strong&gt;Max length&lt;/strong&gt;: 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOffers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOffersRequest($format = null, $limit = null, $marketplace_id = null, $offset = null, $sku = null, string $contentType = self::contentTypes['getOffers'][0])
    {







        $resourcePath = '/offer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_id,
            'marketplace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation publishOffer
     *
     * @param  string $offer_id The unique identifier of the offer that is to be published. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\PublishResponse
     */
    public function publishOffer($offer_id, string $contentType = self::contentTypes['publishOffer'][0])
    {
        list($response) = $this->publishOfferWithHttpInfo($offer_id, $contentType);
        return $response;
    }

    /**
     * Operation publishOfferWithHttpInfo
     *
     * @param  string $offer_id The unique identifier of the offer that is to be published. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\PublishResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function publishOfferWithHttpInfo($offer_id, string $contentType = self::contentTypes['publishOffer'][0])
    {
        $request = $this->publishOfferRequest($offer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\PublishResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\PublishResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\PublishResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\PublishResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\PublishResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation publishOfferAsync
     *
     * @param  string $offer_id The unique identifier of the offer that is to be published. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishOfferAsync($offer_id, string $contentType = self::contentTypes['publishOffer'][0])
    {
        return $this->publishOfferAsyncWithHttpInfo($offer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation publishOfferAsyncWithHttpInfo
     *
     * @param  string $offer_id The unique identifier of the offer that is to be published. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishOfferAsyncWithHttpInfo($offer_id, string $contentType = self::contentTypes['publishOffer'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\PublishResponse';
        $request = $this->publishOfferRequest($offer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'publishOffer'
     *
     * @param  string $offer_id The unique identifier of the offer that is to be published. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function publishOfferRequest($offer_id, string $contentType = self::contentTypes['publishOffer'][0])
    {

        // verify the required parameter 'offer_id' is set
        if ($offer_id === null || (is_array($offer_id) && count($offer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offer_id when calling publishOffer'
            );
        }


        $resourcePath = '/offer/{offerId}/publish/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($offer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'offerId' . '}',
                ObjectSerializer::toPathValue($offer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation publishOfferByInventoryItemGroup
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\PublishByInventoryItemGroupRequest $publish_by_inventory_item_group_request The identifier of the inventory item group to publish and the eBay marketplace where the listing will be published is needed in the request payload. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\PublishResponse
     */
    public function publishOfferByInventoryItemGroup($publish_by_inventory_item_group_request, string $contentType = self::contentTypes['publishOfferByInventoryItemGroup'][0])
    {
        list($response) = $this->publishOfferByInventoryItemGroupWithHttpInfo($publish_by_inventory_item_group_request, $contentType);
        return $response;
    }

    /**
     * Operation publishOfferByInventoryItemGroupWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\PublishByInventoryItemGroupRequest $publish_by_inventory_item_group_request The identifier of the inventory item group to publish and the eBay marketplace where the listing will be published is needed in the request payload. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\PublishResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function publishOfferByInventoryItemGroupWithHttpInfo($publish_by_inventory_item_group_request, string $contentType = self::contentTypes['publishOfferByInventoryItemGroup'][0])
    {
        $request = $this->publishOfferByInventoryItemGroupRequest($publish_by_inventory_item_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\PublishResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\PublishResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\PublishResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\PublishResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\PublishResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation publishOfferByInventoryItemGroupAsync
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\PublishByInventoryItemGroupRequest $publish_by_inventory_item_group_request The identifier of the inventory item group to publish and the eBay marketplace where the listing will be published is needed in the request payload. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishOfferByInventoryItemGroupAsync($publish_by_inventory_item_group_request, string $contentType = self::contentTypes['publishOfferByInventoryItemGroup'][0])
    {
        return $this->publishOfferByInventoryItemGroupAsyncWithHttpInfo($publish_by_inventory_item_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation publishOfferByInventoryItemGroupAsyncWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\PublishByInventoryItemGroupRequest $publish_by_inventory_item_group_request The identifier of the inventory item group to publish and the eBay marketplace where the listing will be published is needed in the request payload. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishOfferByInventoryItemGroupAsyncWithHttpInfo($publish_by_inventory_item_group_request, string $contentType = self::contentTypes['publishOfferByInventoryItemGroup'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\PublishResponse';
        $request = $this->publishOfferByInventoryItemGroupRequest($publish_by_inventory_item_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'publishOfferByInventoryItemGroup'
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\PublishByInventoryItemGroupRequest $publish_by_inventory_item_group_request The identifier of the inventory item group to publish and the eBay marketplace where the listing will be published is needed in the request payload. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function publishOfferByInventoryItemGroupRequest($publish_by_inventory_item_group_request, string $contentType = self::contentTypes['publishOfferByInventoryItemGroup'][0])
    {

        // verify the required parameter 'publish_by_inventory_item_group_request' is set
        if ($publish_by_inventory_item_group_request === null || (is_array($publish_by_inventory_item_group_request) && count($publish_by_inventory_item_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publish_by_inventory_item_group_request when calling publishOfferByInventoryItemGroup'
            );
        }


        $resourcePath = '/offer/publish_by_inventory_item_group/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($publish_by_inventory_item_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($publish_by_inventory_item_group_request));
            } else {
                $httpBody = $publish_by_inventory_item_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOffer
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  string $offer_id The unique identifier of the offer that is being updated. This identifier is passed in at the end of the call URI. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithId $ebay_offer_details_with_id Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\OfferResponse
     */
    public function updateOffer($content_language, $offer_id, $ebay_offer_details_with_id, string $contentType = self::contentTypes['updateOffer'][0])
    {
        list($response) = $this->updateOfferWithHttpInfo($content_language, $offer_id, $ebay_offer_details_with_id, $contentType);
        return $response;
    }

    /**
     * Operation updateOfferWithHttpInfo
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  string $offer_id The unique identifier of the offer that is being updated. This identifier is passed in at the end of the call URI. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithId $ebay_offer_details_with_id Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\OfferResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOfferWithHttpInfo($content_language, $offer_id, $ebay_offer_details_with_id, string $contentType = self::contentTypes['updateOffer'][0])
    {
        $request = $this->updateOfferRequest($content_language, $offer_id, $ebay_offer_details_with_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\OfferResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\OfferResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\OfferResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\OfferResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\OfferResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOfferAsync
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  string $offer_id The unique identifier of the offer that is being updated. This identifier is passed in at the end of the call URI. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithId $ebay_offer_details_with_id Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOfferAsync($content_language, $offer_id, $ebay_offer_details_with_id, string $contentType = self::contentTypes['updateOffer'][0])
    {
        return $this->updateOfferAsyncWithHttpInfo($content_language, $offer_id, $ebay_offer_details_with_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOfferAsyncWithHttpInfo
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  string $offer_id The unique identifier of the offer that is being updated. This identifier is passed in at the end of the call URI. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithId $ebay_offer_details_with_id Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOfferAsyncWithHttpInfo($content_language, $offer_id, $ebay_offer_details_with_id, string $contentType = self::contentTypes['updateOffer'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\OfferResponse';
        $request = $this->updateOfferRequest($content_language, $offer_id, $ebay_offer_details_with_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOffer'
     *
     * @param  string $content_language This request header sets the natural language that will be provided in the field values of the request payload. (required)
     * @param  string $offer_id The unique identifier of the offer that is being updated. This identifier is passed in at the end of the call URI. (required)
     * @param  \OpenAPI\EbayInventoryClient\Model\EbayOfferDetailsWithId $ebay_offer_details_with_id Details of the offer for the channel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOfferRequest($content_language, $offer_id, $ebay_offer_details_with_id, string $contentType = self::contentTypes['updateOffer'][0])
    {

        // verify the required parameter 'content_language' is set
        if ($content_language === null || (is_array($content_language) && count($content_language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_language when calling updateOffer'
            );
        }

        // verify the required parameter 'offer_id' is set
        if ($offer_id === null || (is_array($offer_id) && count($offer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offer_id when calling updateOffer'
            );
        }

        // verify the required parameter 'ebay_offer_details_with_id' is set
        if ($ebay_offer_details_with_id === null || (is_array($ebay_offer_details_with_id) && count($ebay_offer_details_with_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ebay_offer_details_with_id when calling updateOffer'
            );
        }


        $resourcePath = '/offer/{offerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($content_language !== null) {
            $headerParams['Content-Language'] = ObjectSerializer::toHeaderValue($content_language);
        }

        // path params
        if ($offer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'offerId' . '}',
                ObjectSerializer::toPathValue($offer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ebay_offer_details_with_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ebay_offer_details_with_id));
            } else {
                $httpBody = $ebay_offer_details_with_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation withdrawOffer
     *
     * @param  string $offer_id The unique identifier of the offer that is to be withdrawn. This value is passed into the path of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\EbayInventoryClient\Model\WithdrawResponse
     */
    public function withdrawOffer($offer_id, string $contentType = self::contentTypes['withdrawOffer'][0])
    {
        list($response) = $this->withdrawOfferWithHttpInfo($offer_id, $contentType);
        return $response;
    }

    /**
     * Operation withdrawOfferWithHttpInfo
     *
     * @param  string $offer_id The unique identifier of the offer that is to be withdrawn. This value is passed into the path of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOffer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\EbayInventoryClient\Model\WithdrawResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function withdrawOfferWithHttpInfo($offer_id, string $contentType = self::contentTypes['withdrawOffer'][0])
    {
        $request = $this->withdrawOfferRequest($offer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\EbayInventoryClient\Model\WithdrawResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\EbayInventoryClient\Model\WithdrawResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\EbayInventoryClient\Model\WithdrawResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\EbayInventoryClient\Model\WithdrawResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\EbayInventoryClient\Model\WithdrawResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation withdrawOfferAsync
     *
     * @param  string $offer_id The unique identifier of the offer that is to be withdrawn. This value is passed into the path of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function withdrawOfferAsync($offer_id, string $contentType = self::contentTypes['withdrawOffer'][0])
    {
        return $this->withdrawOfferAsyncWithHttpInfo($offer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation withdrawOfferAsyncWithHttpInfo
     *
     * @param  string $offer_id The unique identifier of the offer that is to be withdrawn. This value is passed into the path of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function withdrawOfferAsyncWithHttpInfo($offer_id, string $contentType = self::contentTypes['withdrawOffer'][0])
    {
        $returnType = '\OpenAPI\EbayInventoryClient\Model\WithdrawResponse';
        $request = $this->withdrawOfferRequest($offer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'withdrawOffer'
     *
     * @param  string $offer_id The unique identifier of the offer that is to be withdrawn. This value is passed into the path of the call URI. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOffer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function withdrawOfferRequest($offer_id, string $contentType = self::contentTypes['withdrawOffer'][0])
    {

        // verify the required parameter 'offer_id' is set
        if ($offer_id === null || (is_array($offer_id) && count($offer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offer_id when calling withdrawOffer'
            );
        }


        $resourcePath = '/offer/{offerId}/withdraw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($offer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'offerId' . '}',
                ObjectSerializer::toPathValue($offer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation withdrawOfferByInventoryItemGroup
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\WithdrawByInventoryItemGroupRequest $withdraw_by_inventory_item_group_request The base request of the &lt;strong&gt;withdrawOfferByInventoryItemGroup&lt;/strong&gt; call. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function withdrawOfferByInventoryItemGroup($withdraw_by_inventory_item_group_request, string $contentType = self::contentTypes['withdrawOfferByInventoryItemGroup'][0])
    {
        $this->withdrawOfferByInventoryItemGroupWithHttpInfo($withdraw_by_inventory_item_group_request, $contentType);
    }

    /**
     * Operation withdrawOfferByInventoryItemGroupWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\WithdrawByInventoryItemGroupRequest $withdraw_by_inventory_item_group_request The base request of the &lt;strong&gt;withdrawOfferByInventoryItemGroup&lt;/strong&gt; call. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\EbayInventoryClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function withdrawOfferByInventoryItemGroupWithHttpInfo($withdraw_by_inventory_item_group_request, string $contentType = self::contentTypes['withdrawOfferByInventoryItemGroup'][0])
    {
        $request = $this->withdrawOfferByInventoryItemGroupRequest($withdraw_by_inventory_item_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation withdrawOfferByInventoryItemGroupAsync
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\WithdrawByInventoryItemGroupRequest $withdraw_by_inventory_item_group_request The base request of the &lt;strong&gt;withdrawOfferByInventoryItemGroup&lt;/strong&gt; call. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function withdrawOfferByInventoryItemGroupAsync($withdraw_by_inventory_item_group_request, string $contentType = self::contentTypes['withdrawOfferByInventoryItemGroup'][0])
    {
        return $this->withdrawOfferByInventoryItemGroupAsyncWithHttpInfo($withdraw_by_inventory_item_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation withdrawOfferByInventoryItemGroupAsyncWithHttpInfo
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\WithdrawByInventoryItemGroupRequest $withdraw_by_inventory_item_group_request The base request of the &lt;strong&gt;withdrawOfferByInventoryItemGroup&lt;/strong&gt; call. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function withdrawOfferByInventoryItemGroupAsyncWithHttpInfo($withdraw_by_inventory_item_group_request, string $contentType = self::contentTypes['withdrawOfferByInventoryItemGroup'][0])
    {
        $returnType = '';
        $request = $this->withdrawOfferByInventoryItemGroupRequest($withdraw_by_inventory_item_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'withdrawOfferByInventoryItemGroup'
     *
     * @param  \OpenAPI\EbayInventoryClient\Model\WithdrawByInventoryItemGroupRequest $withdraw_by_inventory_item_group_request The base request of the &lt;strong&gt;withdrawOfferByInventoryItemGroup&lt;/strong&gt; call. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['withdrawOfferByInventoryItemGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function withdrawOfferByInventoryItemGroupRequest($withdraw_by_inventory_item_group_request, string $contentType = self::contentTypes['withdrawOfferByInventoryItemGroup'][0])
    {

        // verify the required parameter 'withdraw_by_inventory_item_group_request' is set
        if ($withdraw_by_inventory_item_group_request === null || (is_array($withdraw_by_inventory_item_group_request) && count($withdraw_by_inventory_item_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $withdraw_by_inventory_item_group_request when calling withdrawOfferByInventoryItemGroup'
            );
        }


        $resourcePath = '/offer/withdraw_by_inventory_item_group';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($withdraw_by_inventory_item_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($withdraw_by_inventory_item_group_request));
            } else {
                $httpBody = $withdraw_by_inventory_item_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
